<!doctype html>
<html class="not-ready lg:text-base overflow-y-scroll scroll-pt-14" lang="zh">

<head prefix="og: https://ogp.me/ns# article: https://ogp.me/ns/article#">
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta name="generator" content="Zola" />
  <title>LISP 模式：图灵完备及元编程 | 错行</title>
  <meta property="og:site_name" content="错行" />
  <meta property="og:title" content="LISP 模式：图灵完备及元编程" />
  <meta name="description" content="关于最早的 LISP 的核心想法，它如何实现图灵完备及元编程，及在此基础上的扩展和现状。" />
  <meta property="og:description" content="关于最早的 LISP 的核心想法，它如何实现图灵完备及元编程，及在此基础上的扩展和现状。" />
  <meta property="og:url" content="https://rratic.github.io/posts/mode-lisp/" />
  <link rel="canonical" href="https://rratic.github.io/posts/mode-lisp/" />
  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2025-03-22T00:00:00+00:00" />
  <meta property="article:modified_time" content="2025-03-29T00:00:00+00:00" />
  <meta property="article:tag" content="笔记" />
  <meta property="article:tag" content="数学" />
  <meta property="article:tag" content="计算机" />
  <meta property="article:tag" content="函数式编程" />
  <meta property="article:tag" content="Lisp" />
  <link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/" />
  <!-- Begin Head inject -->
  <link rel="icon" type="image/x-icon" sizes="16x16" href="https://rratic.github.io/favicon.svg" />
<link rel="my stylesheet" as="style" href="https://rratic.github.io/style/shared.css?h=74471d1f38c46232d571" />

  <!-- End Head inject -->
  <link rel="stylesheet" href="https://rratic.github.io/main.min.css?h=2e89f7f30f1019877d14" />
  <style>
  :root{--bg: white; --header: #e6f4ff; color-scheme: light;}
  :root.dark{--bg: #424242; --header: #333333; color-scheme: dark;}
  </style>
  <meta name="theme-color" data-light="#e6f4ff" data-dark="#333333" content="#e6f4ff" />
  <script src="https://rratic.github.io/js/linkita.min.js?h=1dd3ed42fc674277bc34"></script>
  <link rel="stylesheet" href="https://rratic.github.io/katex/katex.min.css?h=19095127357ed6d29fe0" />
  <script defer src="https://rratic.github.io/katex/katex.min.js?h=e8d885505949f3a5f4ab"></script>
  <script defer src="https://rratic.github.io/katex/contrib/auto-render.min.js?h=bb53eb953394531aae36"></script>
  <script>document.addEventListener("DOMContentLoaded", window.linkita.initKatex);</script>
  <!-- Begin Head End inject -->
  
  <!-- End Head End inject -->
</head>

<body class="text-black duration-100 ease-out bg-[var(--bg)] dark:text-white">
  <!-- Header -->
<header class="bg-[var(--header)] fixed top-0 z-40 mx-auto min-h-[3.25rem] w-full header-icons">
  <div class="mx-auto w-full max-w-4xl p-2.5 lg:flex lg:justify-between">
    <div class="flex justify-between">
      <div class="flex items-center min-h-8">
        <a title="转到主页" accesskey="!"
          href="https://rratic.github.io/" class="text-2xl font-semibold">错行</a>
        <button type="button" title="切换颜色方案" accesskey="$"
          onclick="window.linkita.toggleDarkMode();" ondblclick="window.linkita.resetDarkMode();"
          class="btn-dark ml-4 h-6 w-6 shrink-0 cursor-pointer text-[0] bg-center bg-no-repeat bg-cover dark:invert [background-image:var(--icon-theme-dark)] dark:[background-image:var(--icon-theme-light)]"
        ></button>
      </div>
      <div title="导航" role="button" accesskey="+" tabindex="0"
        class="btn-menu relative z-50 flex h-8 w-8 shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
        onclick="window.linkita.toggleHeaderMenu();"
        onkeydown="(event.keyCode == 13 || event.keyCode == 32) ? event.preventDefault() || window.linkita.toggleHeaderMenu() : true;"
      ></div>
    </div>
    <nav class="flex w-full items-center lg:w-auto">
      <menu
        class="nav-wrapper flex w-full flex-col py-2 lg:w-auto lg:flex-row lg:self-center lg:py-0">
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://rratic.github.io/posts/"
          >文章</a>
        </li>
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://rratic.github.io/categories/"
          >分类</a>
        </li>
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://rratic.github.io/tags/"
          >标签</a>
        </li>
      </menu>
      <!-- Begin Header Nav inject -->
      
      <!-- End Header Nav inject -->
    </nav>
  </div>
</header>

  <!-- Begin Body Start inject -->
  
  <!-- End Body Start inject -->
  <main class="prose prose-neutral relative mx-auto min-h-[calc(100%-4rem)]
    max-w-3xl break-words px-4 pb-12 pt-28 lg:pt-32 dark:prose-invert prose-pre:rounded-lg prose-img:rounded-lg">
    
<article>
  <!-- Begin Page Start inject -->
  
  <!-- End Page Start inject -->

  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">LISP 模式：图灵完备及元编程</h1>
    <!-- Page Info -->
<div class="text-sm antialiased opacity-80"><time
      datetime="2025-03-22T00:00:00+00:00">2025-03-22</time><span
        class="middot"></span>↻ <time
      datetime="2025-03-29T00:00:00+00:00">2025-03-29</time><span
        class="middot"></span><time
    datetime="PT0H20M0S">20&nbsp;分钟</time><span
      class="middot"></span><span>Rratic</span>
</div>

  </header>
  <!-- TOC -->
<div class="block-bg mb-12 rounded-lg p-2 text-lg">
  <details>
    <summary class="select-none py-0.5 lg:py-1 pl-4" accesskey="=">
      <span class="cursor-pointer">目录</span>
    </summary>
    <div class="px-2">
      <ul>
        <li>
          <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#about">介绍</a>
        </li>
        <li>
          <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#roots-of-lisp">Lisp 之根源</a>
          <ul>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#s-expression">S-表达式</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#primitive-operators">原始操作符</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#denoting-functions">函数</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#mark-for-recursive-functions">递归记号</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#some-functions">一些函数</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#evaluation">求值</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#review">反思</a>
            </li>
          </ul>
        </li>
        <li>
          <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#introduce-side-effects">引入副作用</a>
          <ul>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#conclusion">概述</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#lisp-dialects">LISP 方言</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#related-items">相关内容</a>
            </li>
          </ul>
        </li>
        <li>
          <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#dilemma">困境</a>
          <ul>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#downside">缺陷</a>
            </li>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#complexity">复杂性</a>
            </li>
          </ul>
        </li>
        <li>
          <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#aftermath">后记</a>
          <ul>
            <li>
              <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#aftermath-roots-of-lisp">The Roots of Lisp 的说明</a>
            </li>
          </ul>
        </li>
        <li>
          <a class="no-underline hover:underline" href="https://rratic.github.io/posts/mode-lisp/#footnotes">注释</a>
        </li>
      </ul>
    </div>
  </details>
</div>

  <!-- Content -->
  <section><p>前置知识</p>
<ul>
<li><a href="/posts/lambda-calculus/">无类型 λ 演算</a></li>
</ul>
<hr />
<h2 id="about">介绍</h2>
<p>在 1960 年，John McCarthy 发表了一篇划时代的论文。其对编程的贡献有如欧几里德对几何的贡献。<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>这篇论文中定义了一个名为 Lisp（意为 list processing）的编程语言。Paul Graham 认为，“目前为止只有两种真正干净利落，始终如一的编程模式：C 语言模式和 Lisp 语言模式。此二者就象两座高地……随着计算机变得越来越强大，新开发的语言一直在坚定地趋向于 Lisp 模式。”</p>
<p>Lisp 似乎受到了 Lambda 演算与 Kleene 的递归论的影响，但不完全来自于它们。</p>
<h2 id="roots-of-lisp">Lisp 之根源</h2>
<p>本部分参考了<a href="https://www-formal.stanford.edu/jmc/recursive.pdf">其原始论文</a>。</p>
<p>另参考了 <a href="http://www.paulgraham.com/">Paul Graham</a> 所作 <a href="https://blog.freecloud.dev/img/the-roots-of-lisp.pdf">The Roots of Lisp</a>。找到了其一个 2003 年的译本 <a href="http://daiyuwen.freeshell.org/gb/rol/roots_of_lisp.html">Lisp 之根源</a>，但该翻译多有谬误。</p>
<h3 id="s-expression">S-表达式</h3>
<p>一个表达式（expression）可以是：</p>
<ul>
<li>一个原子（atom），在这里是一个连续的字母序列，如 <code>foo</code>。</li>
<li>一个表（list），表达方式形如 <code>()</code>，<code>(foo)</code>，<code>(foo bar)</code>，其中含有零个、一个、两个或多个表达式。</li>
</ul>
<p>可见 <code>(foo (bar) baz)</code> 是表达式。</p>
<p>在 Lisp 中，合法的表达式有值（value），求值往往是默认进行的。<sup class="footnote-reference"><a href="#evaluate">2</a></sup></p>
<h3 id="primitive-operators">原始操作符</h3>
<p>只有七个原始操作符：<code>quote</code>，<code>atom</code>，<code>eq</code>，<code>car</code>，<code>cdr</code>，<code>cons</code> 和 <code>cond</code>。</p>
<p><code>(quote x)</code> 会返回未求值的 <code>x</code>，整个 <code>(quote x)</code> 也被简记为 <code>'x</code>。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">quote</span><span> a)
</span><span>a
</span><span>&gt; &#39;a
</span><span>a
</span><span>&gt; (</span><span style="color:#f07171;">quote </span><span>(a b c))
</span><span>(a b c)
</span></code></pre>
<p><code>(atom x)</code> 会在 $x$ 是原子或空表时返回原子 <code>t</code>，否则返回 <code>()</code>。
按惯例用原子 <code>t</code> 表示真，用空表表示假。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">atom</span><span> &#39;a)
</span><span>t
</span><span>&gt; (</span><span style="color:#f07171;">atom</span><span> &#39;(a b c))
</span><span>()
</span><span>&gt; (</span><span style="color:#f07171;">atom</span><span> &#39;())
</span><span>t
</span></code></pre>
<p>这时，通过使用 <code>quote</code> 可以避免表达式被求值。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">atom </span><span>(</span><span style="color:#f07171;">atom</span><span> &#39;a))
</span><span>t
</span><span>&gt; (</span><span style="color:#f07171;">atom</span><span> &#39;(</span><span style="color:#f07171;">atom</span><span> &#39;a))
</span><span>()
</span></code></pre>
<p>第一例实质上是 <code>(atom t)</code>，因此返回真，而第二例中 <code>atom</code> 后则是一个表，因此返回假。</p>
<p><code>quote</code> 的作用即是<strong>引用</strong>，这一奇怪特性来自于 Lisp 最与众不同的特征：代码和数据由相同的结构构成。<sup class="footnote-reference"><a href="#feature">3</a></sup></p>
<p><code>(eq x y)</code> 会在 $x$ 和 $y$ 的值是同一个原子或都是空表时返回 <code>t</code>，否则返回 <code>()</code>。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#ed9366;">eq</span><span> &#39;a &#39;a)
</span><span>t
</span><span>&gt; (</span><span style="color:#ed9366;">eq</span><span> &#39;a &#39;b)
</span><span>()
</span><span>&gt; (</span><span style="color:#ed9366;">eq</span><span> &#39;() &#39;())
</span><span>t
</span></code></pre>
<p><code>(car x)</code> 期望 $x$ 的值是一个表，并且返回 $x$ 的第一个元素。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">car</span><span> &#39;(a b c))
</span><span>a
</span></code></pre>
<p><code>(cdr x)</code> 期望 $x$ 的值是一个表，并且返回 $x$ 的第一个元素之后的所有元素。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">cdr</span><span> &#39;(a b c))
</span><span>(b c)
</span></code></pre>
<p><code>(cons x y)</code> 期望 $y$ 的值是一个表，并且返回一个新表，其第一个元素是 $x$ 的值，之后是 $y$ 的值的各个元素。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">cons</span><span> &#39;a &#39;(b c))
</span><span>(a b c)
</span><span>&gt; (</span><span style="color:#f07171;">cons</span><span> &#39;a (</span><span style="color:#f07171;">cons</span><span> &#39;b (</span><span style="color:#f07171;">cons</span><span> &#39;c &#39;())))
</span><span>(a b c)
</span><span>&gt; (</span><span style="color:#f07171;">car </span><span>(</span><span style="color:#f07171;">cons</span><span> &#39;a &#39;(b c)))
</span><span>a
</span><span>&gt; (</span><span style="color:#f07171;">cdr </span><span>(</span><span style="color:#f07171;">cons</span><span> &#39;a &#39;(b c)))
</span><span>(b c)
</span></code></pre>
<p><code>(cond (p1 e1) ... (pn en))</code> 依次对每个 $p$ 表达式求值直到有一个返回 <code>t</code>，如果能找到这样的 $p$ 表达式，相应的 $e$ 表达式的值作为整个 <code>cond</code> 表达式的返回值。此命名即 <code>condition</code> 简称。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ed9366;">eq</span><span> &#39;a &#39;b) &#39;</span><span style="color:#f07171;">first</span><span>)
</span><span>        ((</span><span style="color:#f07171;">atom</span><span> &#39;a)  &#39;</span><span style="color:#f07171;">second</span><span>))
</span><span>second
</span></code></pre>
<p>易发现 <code>(cond (x y) ('t z))</code> 即为一些语言中的 <code>if x then y else z</code>。</p>
<div class="footnote-definition" id="evaluate"><sup class="footnote-definition-label">2</sup>
<p>当表达式以七个原始操作符中 <code>quote</code>，<code>cond</code> 以外的表达式进行时，它的自变量总是要求值的。其中 <code>cond</code> 不被触及的表达式可以不被求值。</p>
</div>
<p>称这样的操作符为函数。</p>
<h3 id="denoting-functions">函数</h3>


<div
  class="my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]"
  style="--admonition-bg: rgba(83, 211, 230, 0.1);"
>
  <div class="flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1">
    <div
      class="mx-2 h-4 w-4 text-[0] [background:var(--url)_center_center_no-repeat] dark:invert"
      style="--url: url(./icons/info.svg);"
    >
      info
    </div>
    <span><strong>说明</strong></span>
  </div>
  <div class="pl-4"><p>从这里开始的内容并非原始的定义。你将在<a href="#evaluation">求值</a>中看到它们如何起作用。</p>
</div>
</div>
<p>函数表示为 <code>(lambda (p1 ... pn) e)</code>，其中 $p_i$ 是原子，称为参数，$e$ 是表达式。</p>
<p>如果表达式形如 <code>((lambda (p1 ... pn) e) a1 ... an)</code> 则称为函数调用。
它的值计算如下：每一个表达式 $a_i$ 先求值，然后 $e$ 再求值。在 $e$ 的求值过程中，每个出现在 $e$ 中的 $p_i$ 的值是相应的 $a_i$ 在最近一次的函数调用中的值。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; ((</span><span style="color:#f07171;">lambda </span><span>(x) (</span><span style="color:#f07171;">cons</span><span> x &#39;(b))) &#39;a)
</span><span>(a b)
</span><span>&gt; ((</span><span style="color:#f07171;">lambda </span><span>(x y) (</span><span style="color:#f07171;">cons</span><span> x (</span><span style="color:#f07171;">cdr</span><span> y)))
</span><span>   &#39;z
</span><span>   &#39;(a b c))
</span><span>(z b c)
</span></code></pre>
<p>如果一个表达式的第一个元素 $f$ 是原子且 $f$ 不是原始操作符，形如 <code>(f a1 ... an)</code> 且 $f$ 的值是一个函数<code>(lambda (p1 ... pn) e)</code>，则以上表达式的值就是 <code>((lambda (p1 ... pn) e) a1 ... an)</code> 的值。</p>
<p>这意味着，参数在表达式中可以作为操作符使用。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; ((</span><span style="color:#f07171;">lambda </span><span>(</span><span style="color:#f07171;">f</span><span>) (</span><span style="color:#f07171;">f</span><span> &#39;(b c)))
</span><span>   &#39;(</span><span style="color:#f07171;">lambda </span><span>(x) (</span><span style="color:#f07171;">cons</span><span> &#39;a x)))
</span><span>(a b c)
</span></code></pre>
<p>有另外一个函数记号使得函数能提及它本身，使我们能方便地定义递归函数。</p>
<h3 id="mark-for-recursive-functions">递归记号</h3>
<p>理论上说，引入新的记号是可以通过<a href="/posts/lambda-calculus/#recursive-functions">组合子</a>避免的。</p>
<p>不管是为了降低复杂性还是组合子提出太晚，让我们引入记号 <code>label</code>。</p>
<p>用 <code>(label f (lambda (p1 ... pn) e))</code> 表示形如 <code>(lambda (p1 ... pn) e)</code> 的函数，并允许表达式 $e$ 中的原子 $f$ 对应整个函数 $f$。</p>
<p>假设我们要定义函数 <code>subst</code> 使 <code>(subst x y z)</code>，其中 $x$ 为表达式，$y$ 为原子，$z$ 为表，得到一个基于 $z$ 的表，但其中所有的（任意深度的）原子 $y$ 被替换为 $x$ 的值。如：</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">subst</span><span> &#39;m &#39;b &#39;(a b (a b c) </span><span style="color:#fa6e32;">d</span><span>))
</span><span>(a m (a m c) </span><span style="color:#fa6e32;">d</span><span>)
</span></code></pre>
<p>这个函数可以被定义为：</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(label </span><span style="color:#f07171;">subst </span><span>(</span><span style="color:#f07171;">lambda </span><span>(x y z)
</span><span>               (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">atom</span><span> z)
</span><span>                      (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ed9366;">eq</span><span> z y) x)
</span><span>                            (&#39;</span><span style="color:#ff8f40;">t</span><span> z)))
</span><span>                     (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">subst</span><span> x y (</span><span style="color:#f07171;">car</span><span> z))
</span><span>                               (</span><span style="color:#f07171;">subst</span><span> x y (</span><span style="color:#f07171;">cdr</span><span> z)))))))
</span></code></pre>
<p>让我们缩写 <code>(label f (lambda (p1 ... pn) e))</code> 为 <code>(defun f (p1 ... pn) e)</code>，并且允许其定义的函数被保留下来。就有：</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">subst </span><span>(x y z)
</span><span>  (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">atom</span><span> z)
</span><span>         (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ed9366;">eq</span><span> z y) x)
</span><span>               (&#39;</span><span style="color:#ff8f40;">t</span><span> z)))
</span><span>        (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">subst</span><span> x y (</span><span style="color:#f07171;">car</span><span> z))
</span><span>                  (</span><span style="color:#f07171;">subst</span><span> x y (</span><span style="color:#f07171;">cdr</span><span> z))))))
</span></code></pre>
<p>假定我们定义了运算符号，那么可以看到 S-表达式实际上使用了波兰标记法。</p>
<p>如 $a\times b+c^d$ 被表达为 <code>(+ (* a b) (^ c d))</code>。</p>
<h3 id="some-functions">一些函数</h3>
<p>让我们定义一些新的函数。</p>
<p>首先我们用形如 <code>cxr</code> 的序列定义 <code>car</code> 和 <code>cdr</code> 的组合，如 <code>(cadr e)</code> 为 <code>(car (cdr e))</code> 的缩写。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">cadr</span><span> &#39;((a b) (c </span><span style="color:#fa6e32;">d</span><span>) e))
</span><span>(c </span><span style="color:#fa6e32;">d</span><span>)
</span><span>&gt; (</span><span style="color:#f07171;">caddr</span><span> &#39;((a b) (c </span><span style="color:#fa6e32;">d</span><span>) e))
</span><span>e
</span><span>&gt; (</span><span style="color:#f07171;">cdar</span><span> &#39;((a b) (c </span><span style="color:#fa6e32;">d</span><span>) e))
</span><span>(b)
</span></code></pre>
<p>再用 <code>(list e1 ... en)</code> 代替 <code>(cons e1 ... (cons en '()) ... )</code>。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">cons</span><span> &#39;a (</span><span style="color:#f07171;">cons</span><span> &#39;b (</span><span style="color:#f07171;">cons</span><span> &#39;c &#39;())))
</span><span>(a b c)
</span><span>&gt; (</span><span style="color:#f07171;">list</span><span> &#39;a &#39;b &#39;c)
</span><span>(a b c)
</span></code></pre>
<p>接下来定义一些常见的逻辑工具。</p>
<p>在原文中为防止和 Common Lisp 存在的函数重复而无法在 Common Lisp 中运行，在函数名后加 <code>.</code> 来进行区分。这里我们不关心这一点，因此不作此操作。</p>
<p><code>(null x)</code> 检测 $x$ 是否为空表。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">null </span><span>(x)
</span><span>  (</span><span style="color:#ed9366;">eq</span><span> x &#39;()))
</span><span>
</span><span>&gt; (</span><span style="color:#ff8f40;">null</span><span> &#39;a)
</span><span>()
</span><span>&gt; (</span><span style="color:#ff8f40;">null</span><span> &#39;())
</span><span>t
</span></code></pre>
<p>与。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">and </span><span>(x y)
</span><span>  (</span><span style="color:#fa6e32;">cond </span><span>(x (</span><span style="color:#fa6e32;">cond </span><span>(y &#39;</span><span style="color:#ff8f40;">t</span><span>) (&#39;</span><span style="color:#ff8f40;">t</span><span> &#39;())))
</span><span>        (&#39;</span><span style="color:#ff8f40;">t</span><span> &#39;())))
</span></code></pre>
<p>非。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">not </span><span>(x)
</span><span> (</span><span style="color:#fa6e32;">cond </span><span>(x &#39;())
</span><span>       (&#39;</span><span style="color:#ff8f40;">t</span><span> &#39;</span><span style="color:#ff8f40;">t</span><span>)))
</span></code></pre>
<p><code>(append x y)</code> 将表拼接。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">append </span><span>(x y)
</span><span> (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ff8f40;">null</span><span> x) y)
</span><span>       (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">car</span><span> x) (</span><span style="color:#f07171;">append </span><span>(</span><span style="color:#f07171;">cdr</span><span> x) y)))))
</span></code></pre>
<p><code>(pair x y)</code> 将表 <code>(x y z)</code> 和 <code>(a b c)</code> 变为 <code>((x a) (y b) (z c))</code>。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">pair </span><span>(x y)
</span><span> (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ed9366;">and </span><span>(</span><span style="color:#ff8f40;">null</span><span> x) (</span><span style="color:#ff8f40;">null</span><span> y)) &#39;())
</span><span>       ((</span><span style="color:#ed9366;">and </span><span>(</span><span style="color:#ed9366;">not </span><span>(</span><span style="color:#f07171;">atom</span><span> x)) (</span><span style="color:#ed9366;">not </span><span>(</span><span style="color:#f07171;">atom</span><span> y)))
</span><span>        (</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">list </span><span>(</span><span style="color:#f07171;">car</span><span> x) (</span><span style="color:#f07171;">car</span><span> y))
</span><span>              (pair (</span><span style="color:#f07171;">cdr</span><span> x) (</span><span style="color:#f07171;">cdr</span><span> y))))))
</span></code></pre>
<p><code>(assoc x y)</code> 取原子 $x$ 和形如 <code>pair</code> 返回值的表 $y$，然后返回 $y$ 中每一对中第一个值是 $x$ 所对应的第二个值。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">assoc </span><span>(x y)
</span><span> (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">caar</span><span> y) x) (</span><span style="color:#f07171;">cadar</span><span> y))
</span><span>       (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">assoc</span><span> x (</span><span style="color:#f07171;">cdr</span><span> y)))))
</span></code></pre>
<h3 id="evaluation">求值</h3>
<p>现在我们已有了定义 <code>eval</code> 的所有材料。它可以接受任意 Lisp 表达式然后返回它的值。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">eval </span><span>(e a)
</span><span>  (</span><span style="color:#fa6e32;">cond 
</span><span>    ((</span><span style="color:#f07171;">atom</span><span> e) (</span><span style="color:#f07171;">assoc</span><span> e a))
</span><span>    ((</span><span style="color:#f07171;">atom </span><span>(</span><span style="color:#f07171;">car</span><span> e))
</span><span>     (</span><span style="color:#fa6e32;">cond 
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#f07171;">quote</span><span>) (</span><span style="color:#f07171;">cadr</span><span> e))
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#f07171;">atom</span><span>)  (</span><span style="color:#f07171;">atom   </span><span>(</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cadr</span><span> e) a)))
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#ed9366;">eq</span><span>)    (</span><span style="color:#ed9366;">eq     </span><span>(</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cadr</span><span> e) a)
</span><span>                                    (</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">caddr</span><span> e) a)))
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#f07171;">car</span><span>)   (</span><span style="color:#f07171;">car    </span><span>(</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cadr</span><span> e) a)))
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#f07171;">cdr</span><span>)   (</span><span style="color:#f07171;">cdr    </span><span>(</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cadr</span><span> e) a)))
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#f07171;">cons</span><span>)  (</span><span style="color:#f07171;">cons   </span><span>(</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cadr</span><span> e) a)
</span><span>                                    (</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">caddr</span><span> e) a)))
</span><span>       ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">car</span><span> e) &#39;</span><span style="color:#fa6e32;">cond</span><span>)  (evcon (</span><span style="color:#f07171;">cdr</span><span> e) a))
</span><span>       (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">assoc </span><span>(</span><span style="color:#f07171;">car</span><span> e) a)
</span><span>                        (</span><span style="color:#f07171;">cdr</span><span> e))
</span><span>                 a))))
</span><span>    ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">caar</span><span> e) &#39;label)
</span><span>     (</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">caddar</span><span> e) (</span><span style="color:#f07171;">cdr</span><span> e))
</span><span>           (</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">list </span><span>(</span><span style="color:#f07171;">cadar</span><span> e) (</span><span style="color:#f07171;">car</span><span> e)) a)))
</span><span>    ((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">caar</span><span> e) &#39;</span><span style="color:#f07171;">lambda</span><span>)
</span><span>     (</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">caddar</span><span> e)
</span><span>           (</span><span style="color:#f07171;">append </span><span>(pair (</span><span style="color:#f07171;">cadar</span><span> e) (evlis (</span><span style="color:#f07171;">cdr</span><span> e) a))
</span><span>                   a)))))
</span><span>
</span><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">evcon </span><span>(c a)
</span><span>  (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">caar</span><span> c) a)
</span><span>         (</span><span style="color:#f07171;">eval </span><span>(</span><span style="color:#f07171;">cadar</span><span> c) a))
</span><span>        (&#39;</span><span style="color:#ff8f40;">t </span><span>(evcon (</span><span style="color:#f07171;">cdr</span><span> c) a))))
</span><span>
</span><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">evlis </span><span>(m a)
</span><span>  (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ff8f40;">null</span><span> m) &#39;())
</span><span>        (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">eval  </span><span>(</span><span style="color:#f07171;">car</span><span> m) a)
</span><span>                  (evlis (</span><span style="color:#f07171;">cdr</span><span> m) a)))))
</span></code></pre>
<p>在 <code>(eval e a)</code> 中，$e$ 是将被解析的表达式，而 $a$ 是一个形如 <code>pair</code> 格式的列表，表示原子的值的注册，称为「环境」。</p>
<p><code>eval</code> 的核心是通过条件判断进行的。</p>
<p>第一个分支处理了原子。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">eval</span><span> &#39;x &#39;((x a) (y b)))
</span><span>a
</span></code></pre>
<p>第二个分支处理了原始操作符。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">eval</span><span> &#39;(</span><span style="color:#ed9366;">eq</span><span> &#39;a &#39;a) &#39;())
</span><span>t
</span><span>&gt; (</span><span style="color:#f07171;">eval</span><span> &#39;(</span><span style="color:#f07171;">cons</span><span> x &#39;(b c))
</span><span>        &#39;((x a) (y b)))
</span><span>(a b c)
</span></code></pre>
<p>除 <code>quote</code> 外它们都会调用 <code>eval</code> 自身来递归地得到值。</p>
<p><code>cond</code> 的计算略复杂一些，该部分被放入了辅助函数 <code>evcon</code> 中。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>&gt; (</span><span style="color:#f07171;">eval</span><span> &#39;(</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">atom</span><span> x) &#39;</span><span style="color:#f07171;">atom</span><span>)
</span><span>               (&#39;</span><span style="color:#ff8f40;">t</span><span> &#39;</span><span style="color:#f07171;">list</span><span>))
</span><span>        &#39;((x &#39;(a b))))
</span><span>list
</span></code></pre>
<p>最后一个部分是函数调用。先把原子替换成对应的值（含 <code>label</code> 或 <code>function</code> 的表达式），再调用自身。</p>
<p>如 <code>(eval '(f '(b c)) '((f (lambda (x) (cons 'a x)))))</code> 变为 <code>(eval '((lambda (x) (cons 'a x)) '(b c)) '( ... ))</code>，然后得到 <code>(a b c)</code>。</p>
<p>第三个分支处理 <code>label</code> 函数调用。这会用内部 <code>lambda</code> 表达式替代，并将这一标签置于「环境」中。如，</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#f07171;">eval</span><span> &#39;((label firstatom (</span><span style="color:#f07171;">lambda </span><span>(x)
</span><span>                           (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">atom</span><span> x) x)
</span><span>                                 (&#39;</span><span style="color:#ff8f40;">t </span><span>(firstatom (</span><span style="color:#f07171;">car</span><span> x))))))
</span><span>        y)
</span><span>      &#39;((y ((a b) (c </span><span style="color:#fa6e32;">d</span><span>)))))
</span></code></pre>
<p>会被替代为，</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#f07171;">eval</span><span> &#39;((</span><span style="color:#f07171;">lambda </span><span>(x)
</span><span>          (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">atom</span><span> x) x)
</span><span>          (&#39;</span><span style="color:#ff8f40;">t </span><span>(firstatom (</span><span style="color:#f07171;">car</span><span> x)))))
</span><span>        y)
</span><span>      &#39;((firstatom
</span><span>         (label firstatom (</span><span style="color:#f07171;">lambda </span><span>(x)
</span><span>                          (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#f07171;">atom</span><span> x) x)
</span><span>                                (&#39;</span><span style="color:#ff8f40;">t </span><span>(firstatom (</span><span style="color:#f07171;">car</span><span> x)))))))
</span><span>        (y ((a b) (c </span><span style="color:#fa6e32;">d</span><span>)))))
</span></code></pre>
<p>最终返回 <code>a</code>。</p>
<p>最后一个分支处理 <code>lambda</code> 函数调用。对形如 <code>((lambda (p1 ... pn) e) a1 ... an)</code> 的表达式，<code>a1 ... an</code> 的值会置于「环境」中，对应 <code>p1 ... pn</code>。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#f07171;">eval</span><span> &#39;((</span><span style="color:#f07171;">lambda </span><span>(x y) (</span><span style="color:#f07171;">cons</span><span> x (</span><span style="color:#f07171;">cdr</span><span> y)))
</span><span>        &#39;a
</span><span>        &#39;(b c </span><span style="color:#fa6e32;">d</span><span>))
</span><span>      &#39;())
</span></code></pre>
<p>会变为，</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#f07171;">eval</span><span> &#39;(</span><span style="color:#f07171;">cons</span><span> x (</span><span style="color:#f07171;">cdr</span><span> y))
</span><span>      &#39;((x a) (y (b c </span><span style="color:#fa6e32;">d</span><span>))))
</span></code></pre>
<p>最终返回 <code>(a c d)</code>。</p>
<hr />
<p>这一设计的实现使得仅通过七个原始操作符 <code>quote</code>，<code>atom</code>，<code>eq</code>，<code>car</code>，<code>cdr</code>，<code>cons</code> 和 <code>cond</code> 完成<sup class="footnote-reference"><a href="#only-seven">4</a></sup>一个可用且具备优雅性<sup class="footnote-reference"><a href="#elegant">5</a></sup>的计算模型是可能的（尽管可能相当复杂）。</p>
<h3 id="review">反思</h3>
<p>在 1960 的原始定义中缺乏了很多使用的特性。如语句不会产生 <code>side-effect</code>（即每一个完整的表达式被单独执行，没有联系），因而没有顺序执行流程。并且没有实用的数字（尽管可以用长度为 $n$ 的列表表示，或者<a href="/pages/lambda-calculus/#datatype-number">使用函数表达</a>）。</p>
<p>McCarthy 的想法仍是今日的 Lisp 的语义的核心。Lisp 本质上并非一个为 AI 或 <code>rapid prototyping</code> 等任务设计的工具，它是当你试图公理化计算时的一个产物。</p>
<h2 id="introduce-side-effects">引入副作用</h2>
<h3 id="conclusion">概述</h3>
<p>如果想要阅读如何构建一个有 <code>side-effect</code> 的解释器并且完成一些任务，可以阅读 <code>AI Memo No. 543</code>。<sup class="footnote-reference"><a href="#3">6</a></sup>这篇文章里充满了技术细节。</p>
<p>如果想要在纯编程理论的方向继续前进，可以看看 Scheme。</p>
<p>这里我们讨论解决更现实的问题。不如看看 Common Lisp 是如何设计的。这参阅了 <a href="https://lisp.fullstack.org.cn/learn/getting-started/">Common Lisp 教程</a> 中的内容。</p>
<p>首先，Common Lisp 允许 <code>3.14</code> 这样的数字，及 <code>+</code>，<code>my-variable</code> 等符号作为原子。另用冒号前缀符号表示关键字，其求值后为自身。</p>
<p>这里 <code>t</code> 为真常量。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>CL-USER&gt; (</span><span style="color:#f07171;">format </span><span style="color:#ff8f40;">t </span><span style="color:#86b300;">&quot;Hello, world!&quot;</span><span>)
</span><span>Hello, world!
</span><span>NIL
</span></code></pre>
<p>添加了很多人性化的内置功能。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">defun </span><span style="color:#f29718;">fib </span><span>(n)
</span><span>  </span><span style="color:#86b300;">&quot;Return the nth Fibonacci number.&quot; </span><span style="font-style:italic;color:#abb0b6;">;; 允许一个字符串作为文档
</span><span>  (</span><span style="color:#fa6e32;">if </span><span>(</span><span style="color:#ed9366;">&lt;</span><span> n </span><span style="color:#ff8f40;">2</span><span>) </span><span style="font-style:italic;color:#abb0b6;">;; 函数体声明
</span><span>      n </span><span style="font-style:italic;color:#abb0b6;">;; 省去了 else
</span><span>      (</span><span style="color:#ed9366;">+ </span><span>(fib (</span><span style="color:#ed9366;">-</span><span> n </span><span style="color:#ff8f40;">1</span><span>))
</span><span>         (fib (</span><span style="color:#ed9366;">-</span><span> n </span><span style="color:#ff8f40;">2</span><span>))))) </span><span style="font-style:italic;color:#abb0b6;">;; if 是表达式，因此有返回值
</span></code></pre>
<p>可以以多种方式调用。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(fib </span><span style="color:#ff8f40;">30</span><span>)
</span><span style="font-style:italic;color:#abb0b6;">;; =&gt; 832040
</span><span>
</span><span>(</span><span style="color:#f07171;">funcall </span><span style="color:#ff8f40;">#&#39;fib 30</span><span>)
</span><span style="font-style:italic;color:#abb0b6;">;; =&gt; 832040
</span><span>
</span><span>(</span><span style="color:#f07171;">apply </span><span style="color:#ff8f40;">#&#39;fib </span><span>(</span><span style="color:#f07171;">list </span><span style="color:#ff8f40;">30</span><span>))
</span><span style="font-style:italic;color:#abb0b6;">;; =&gt; 832040
</span></code></pre>
<p>可以声明局部变量。</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#fa6e32;">let </span><span>((x </span><span style="color:#ff8f40;">1</span><span>)
</span><span>      (y </span><span style="color:#ff8f40;">5</span><span>))
</span><span>  (</span><span style="color:#ed9366;">+</span><span> x y))
</span><span>
</span><span style="font-style:italic;color:#abb0b6;">;; =&gt; 6
</span></code></pre>
<p>同时允许全局变量，并允许局部上的作用域覆盖。</p>
<p>支持用 <code>defmacro</code> 定义宏，用 <code>defgeneric</code> 声明通用函数（用 <code>defmethod</code> 声明其方法），用 <code>defclass</code> 定义类。</p>
<p>可见相对于简洁的 Lisp 作出了很大的让步。</p>
<h3 id="lisp-dialects">LISP 方言</h3>
<p>现今有一席之地的 Lisp 方言包括 <code>Common Lisp</code>，<code>Clojure</code>，<code>Scheme</code> 和 <code>Emacs Lisp</code>。</p>
<p>它们为不同的目的而设计了不同的特性，允许安全或不安全的宏。</p>
<p>它们的类型系统都是动态的。</p>


<div
  class="my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]"
  style="--admonition-bg: rgba(255, 145, 0, 0.1);"
>
  <div class="flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1">
    <div
      class="mx-2 h-4 w-4 text-[0] [background:var(--url)_center_center_no-repeat] dark:invert"
      style="--url: url(./icons/warning.svg);"
    >
      warning
    </div>
    <span><strong>警告</strong></span>
  </div>
  <div class="pl-4"><p>本表格基于 DeepSeek 的生成，不保证真实性。</p>
</div>
</div>
<table><thead><tr><th>特性</th><th>Common Lisp</th><th>Clojure</th><th>Scheme</th><th>Emacs Lisp</th></tr></thead><tbody>
<tr><td><strong>设计目标</strong></td><td>通用、多范式</td><td>函数式、并发</td><td>极简、教学导向</td><td>编辑器扩展</td></tr>
<tr><td><strong>主要运行方式</strong></td><td>编译/JIT</td><td>JVM/JS/.NET</td><td>解释/编译</td><td>解释</td></tr>
<tr><td><strong>典型应用领域</strong></td><td>AI、复杂系统</td><td>分布式系统、数据</td><td>教学、语言研究</td><td>编辑器定制、自动化</td></tr>
</tbody></table>
<h3 id="related-items">相关内容</h3>
<p>可以看看其它的函数式语言。典型的如 Haskell。也可以看看 Prolog。</p>
<h2 id="dilemma">困境</h2>


<div
  class="my-4 flex flex-col rounded-lg bg-[var(--admonition-bg)]"
  style="--admonition-bg: rgba(255, 145, 0, 0.1);"
>
  <div class="flex items-center rounded-t-lg bg-[var(--admonition-bg)] p-1">
    <div
      class="mx-2 h-4 w-4 text-[0] [background:var(--url)_center_center_no-repeat] dark:invert"
      style="--url: url(./icons/warning.svg);"
    >
      warning
    </div>
    <span><strong>警告</strong></span>
  </div>
  <div class="pl-4"><p>此段未完全经过验证。</p>
</div>
</div>
<p>我们已经从纯理论与实践两个角度讨论了 Lisp。从表面上看，这种精巧的语言应该被广为接受才对。</p>
<p>然而，按照本句完成时的 <a href="https://www.tiobe.com/tiobe-index/">TIOBE 排名</a>，Lisp 只在第二十三位<sup class="footnote-reference"><a href="#lisp-count">7</a></sup>，方言 Clojure 与 Scheme 在 51~100 位间，其它方言则在 100 位之后。</p>
<p>我们没有银弹。Lisp 的核心理念与任何后续叠加的理念，或者其它任何极好的理念，都不能单一地在生产力、可靠性或简单性方面带来数量级的提升。<sup class="footnote-reference"><a href="#5">8</a></sup></p>
<h3 id="downside">缺陷</h3>
<p>Lisp 的一个明显问题是可读性。S-表达式看起来不符合人类的习惯。</p>
<p>现代的一个可以接受的例子是 <a href="https://docs.juliacn.com/latest/manual/metaprogramming/">Julia 的元编程</a>。这是通过支持在运行时解析字符串实现的。</p>
<pre data-lang="jl" style="background-color:#fafafa;color:#61676c;" class="language-jl "><code class="language-jl" data-lang="jl"><span>julia</span><span style="color:#ed9366;">&gt;</span><span> Meta.parse(</span><span style="color:#86b300;">&quot;1 + 1&quot;</span><span>)
</span><span style="color:#ff8f40;">:</span><span>(</span><span style="color:#ff8f40;">1 </span><span style="color:#ed9366;">+ </span><span style="color:#ff8f40;">1</span><span>)
</span></code></pre>
<p>你甚至可以运行这样的程序。</p>
<pre data-lang="jl" style="background-color:#fafafa;color:#61676c;" class="language-jl "><code class="language-jl" data-lang="jl"><span>expr </span><span style="color:#ed9366;">= </span><span style="color:#ff8f40;">:</span><span>(</span><span style="color:#fa6e32;">function </span><span style="color:#f29718;">f</span><span>(x)
</span><span>    y </span><span style="color:#ed9366;">=</span><span> x </span><span style="color:#ed9366;">^ </span><span style="color:#ff8f40;">2</span><span>;
</span><span>    x </span><span style="color:#ed9366;">+</span><span> y
</span><span style="color:#fa6e32;">end</span><span>)
</span><span>
</span><span>f </span><span style="color:#ed9366;">=</span><span> eval(expr)
</span><span>display(f(</span><span style="color:#ff8f40;">8</span><span>))
</span></code></pre>
<p>另一个明显的问题是性能。在编译器不够强大时，使用汇编进行底层操作，使用 C 模式进行指针操作是十分必要的。但函数式语言难以与这种优化产生联系。此外，动态类型具有较大的空间、时间开销。</p>
<p>可以看看新近的 <a href="https://news.mit.edu/2025/high-performance-computing-with-much-less-code-0313">Exo 2</a>。</p>
<h3 id="complexity">复杂性</h3>
<p>在 The Mythical Man-Month 等诸多著作中都有一个认识，复杂性来自于<strong>本质复杂性</strong>（问题本身的复杂性）和<strong>偶然复杂性</strong>（语言、工具或方法带来的复杂性）这两类。在纯粹模型之外，Lisp 降低的复杂性没有那么大。</p>
<p>Richard P. Gabriel 提出了<sup class="footnote-reference"><a href="#6">9</a></sup>两种设计理念的不同。</p>
<ol>
<li>The Right Thing</li>
</ol>
<ul>
<li>追求设计的完美和完整性。</li>
<li>强调正确性、一致性和优雅性。</li>
<li>倾向于复杂的设计，以满足所有可能的需求。</li>
</ul>
<ol start="2">
<li>Worse is Better</li>
</ol>
<ul>
<li>追求简单性和实用性。</li>
<li>强调快速实现、易于理解和广泛采用。</li>
<li>接受不完美和局限性，优先解决核心问题。</li>
</ul>
<p>后者支持快速迭代和广泛使用，更符合实际需求。</p>
<p>实际上，由于 Lisp 可以较为自由地完成设计，而设计通常会很复杂，Lisp 社区常产生分歧。</p>
<h2 id="aftermath">后记</h2>
<h3 id="aftermath-roots-of-lisp">The Roots of Lisp 的说明</h3>
<blockquote>
<p>In translating McCarthy's notation into running code I tried to change as little
as possible. I was tempted to make the code easier to read, but I wanted to
keep the flavor of the original.</p>
<p>In McCarthy's paper, falsity is represented by <code>f</code>, not the empty list. I used
<code>()</code> to represent falsity so that the examples would work in Common Lisp. The
code nowhere depends on falsity happening also to be the empty list; nothing
is ever consed onto the result returned by a predicate.</p>
<p>I skipped building lists out of dotted pairs, because you don't need them to
understand <code>eval</code>. I also skipped mentioning <code>apply</code>, though it was <code>apply</code> (a very
early form of it, whose main purpose was to quote arguments) that McCarthy
called the universal function in 1960; <code>eval</code> was then just a subroutine that <code>apply</code>
called to do all the work.</p>
<p>I defined <code>list</code> and the <code>cxrs</code> as abbreviations because that's how McCarthy
did it. In fact the <code>cxrs</code> could all have been defined as ordinary functions. So
could <code>list</code> if we modified <code>eval</code>, as we easily could, to let functions take any
number of arguments.</p>
<p>McCarthy's paper only had five primitive operators. He used <code>cond</code> and
<code>quote</code> but may have thought of them as part of his metalanguage. He likewise
didn't define the logical operators <code>and</code> and <code>not</code>, but this is less of a problem
because adequate versions can be defined as functions.</p>
<p>In the definition of <code>eval.</code> we called other functions like <code>pair.</code> and <code>assoc.</code>,
but any call to one of the functions we defined in terms of the primitive operators
could be replaced by a call to <code>eval.</code>. That is,</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#f07171;">assoc</span><span>. (</span><span style="color:#f07171;">car</span><span> e) a)
</span></code></pre>
<p>could have been written as</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(</span><span style="color:#f07171;">eval</span><span>. &#39;((label </span><span style="color:#f07171;">assoc</span><span>.
</span><span>                (</span><span style="color:#f07171;">lambda </span><span>(x y)
</span><span>                  (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ed9366;">eq </span><span>(</span><span style="color:#f07171;">caar</span><span> y) x) (</span><span style="color:#f07171;">cadar</span><span> y))
</span><span>                  (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">assoc</span><span>. x (</span><span style="color:#f07171;">cdr</span><span> y))))))
</span><span>         (</span><span style="color:#f07171;">car</span><span> e)
</span><span>         a)
</span><span>        (</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">list</span><span> &#39;e e) (</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">list</span><span> &#39;a a) a)))
</span></code></pre>
<p>There was a small bug in McCarthy's <code>eval</code>. Line 16 was (equivalent to)
<code>(evlis. (cdr e) a)</code> instead of just <code>(cdr e)</code>, which caused the arguments in
a call to a named function to be evaluated twice. This suggests that this
description of eval had not yet been implemented in IBM 704 machine language
when the paper was submitted. It also shows how hard it is to be sure of the
correctness of any length of program without trying to run it.</p>
<p>I encountered one other problem in McCarthy's code. After giving the
definition of eval he goes on to give some examples of higher-order functions—
functions that take other functions as arguments. He defines <code>maplist</code>:</p>
<pre data-lang="lisp" style="background-color:#fafafa;color:#61676c;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(label </span><span style="color:#fa6e32;">maplist
</span><span>       (</span><span style="color:#f07171;">lambda </span><span>(x </span><span style="color:#f07171;">f</span><span>)
</span><span>         (</span><span style="color:#fa6e32;">cond </span><span>((</span><span style="color:#ff8f40;">null</span><span> x) &#39;())
</span><span>               (&#39;</span><span style="color:#ff8f40;">t </span><span>(</span><span style="color:#f07171;">cons </span><span>(</span><span style="color:#f07171;">f</span><span> x) (</span><span style="color:#fa6e32;">maplist </span><span>(</span><span style="color:#f07171;">cdr</span><span> x) </span><span style="color:#f07171;">f</span><span>))))))
</span></code></pre>
<p>then uses it to write a simple function <code>diff</code> for symbolic differentiation. But
<code>diff</code> passes <code>maplist</code> a function that uses $x$ as a parameter, and the reference
to it is captured by the parameter $x$ within <code>maplist</code>.</p>
<p>It's an eloquent testimony to the dangers of dynamic scope that even the
very first example of higher-order Lisp functions was broken because of it. It
may be that McCarthy was not fully aware of the implications of dynamic scope
in 1960. Dynamic scope remained in Lisp implementations for a surprisingly
long time—until Sussman and Steele developed Scheme in 1975. Lexical scope
does not complicate the definition of eval very much, but it may make compilers
harder to write.</p>
</blockquote>
<h2 id="footnotes">注释</h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>``Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part1.'' Communication of the ACM 3:4, April 1960, pp. 184-195.</p>
</div>
<div class="footnote-definition" id="feature"><sup class="footnote-definition-label">3</sup>
<p>在现实中，生物、语言等具有更复杂的此种特性。</p>
</div>
<div class="footnote-definition" id="only-seven"><sup class="footnote-definition-label">4</sup>
<p>原文如此，但不借助 <code>lambda</code> 等记号完成 <code>eval</code> 的递归特性似乎是不可能的。</p>
</div>
<div class="footnote-definition" id="elegant"><sup class="footnote-definition-label">5</sup>
<p>尽管早有大量图灵完备的模型存在，先前并无具备足够抽象性的语言。而这是发明 Lisp 的目标之一。</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">6</sup>
<p>Guy Lewis Steele, Jr. and Gerald Jay Sussman, ”The Art of the Interpreter, or the Modularity Complex (Parts Zero, One, and Two),” MIT AI Lab Memo 453, May 1978.</p>
</div>
<div class="footnote-definition" id="lisp-count"><sup class="footnote-definition-label">7</sup>
<p>可能是指 Common Lisp。取决于具体的统计方式。</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">8</sup>
<p>No Silver Bullet—Essence and Accident in Software Engineering</p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">9</sup>
<p><a href="https://www.dreamsongs.com/WorseIsBetter.html">https://www.dreamsongs.com/WorseIsBetter.html</a></p>
</div>
<div class="footnote-definition" id="maplist"><sup class="footnote-definition-label">10</sup>
<blockquote>
<p>Present day Lisp programmers would use <code>mapcar</code> instead of <code>maplist</code> here. This example
does clear up one mystery: why <code>maplist</code> is in Common Lisp at all. It was the original mapping
function, and <code>mapcar</code> a later addition.</p>
</blockquote>
</div>
</section>
  <hr />
  <!-- Post Taxonomies -->
<footer class="mt-12 flex flex-col" tabindex="-1" accesskey="_">
  <div class="mb-2 flex flex-wrap">
    <span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">分类</span>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://rratic.github.io/categories/知识/">知识</a>
    
  </div>
  <div class="mb-2 flex flex-wrap">
    <span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">标签</span>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://rratic.github.io/tags/笔记/">笔记</a>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://rratic.github.io/tags/数学/">数学</a>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://rratic.github.io/tags/计算机/">计算机</a>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://rratic.github.io/tags/函数式编程/">函数式编程</a>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://rratic.github.io/tags/Lisp/">Lisp</a>
    
  </div>
</footer>

  <!-- Post Nav -->
<nav class="block-bg mt-12 flex flex-wrap rounded-lg text-lg">
  <a
    class="block-hover-mask flex min-w-[50%] grow items-center rounded-l-md p-6 pr-3 font-semibold no-underline"
    href="https://rratic.github.io/posts/magic-construction/" accesskey=","
    ><span class="mr-1.5">&#8249;</span><span>魔术的构造</span></a>
  <a
    class="block-hover-mask ml-auto flex min-w-[50%] grow items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline"
    href="https://rratic.github.io/posts/cat-chess/" accesskey="."
    ><span>猫猫棋：一个棋子可变的游戏设计</span><span class="ml-1.5">&#8250;</span></a>
</nav>

  <!-- Comment -->
<div class="giscus mt-12"></div>
<script
  src="https://giscus.app/client.js"
  data-repo="Rratic/pages"
  data-repo-id="MDEwOlJlcG9zaXRvcnkzMzAxOTc5OTQ="
  data-category="General"
  data-category-id="DIC_kwDOE65r6s4CoFkL"
  data-mapping="og:title"
  data-strict="1"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="top"
  data-theme="preferred_color_scheme"
  data-lang="zh-CN"
  data-loading="lazy"
  crossorigin="anonymous"
  async
></script>

  <!-- Begin Page End inject -->
  
  <!-- End Page End inject -->
</article>

  </main>
  <!-- Footer -->
<footer class="mx-auto flex lg:mt-5 max-w-3xl flex-wrap items-center px-4 py-3 text-sm opacity-60">
  <div class="mr-auto basis-full lg:basis-1/2">
  © <time datetime="2025">2025</time> Rratic | <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>
  </div>
  <div class="flex basis-full lg:basis-1/2 lg:justify-end">
    <span class="mr-6 lg:ml-6">
      <a class="link" href="https://www.getzola.org/" target="_blank">Powered by Zola</a>
    </span>
    <a class="link" href="https://www.getzola.org/themes/linkita/" target="_blank">&#9998; Linkita</a>
  </div>
  <!-- Begin Footer inject -->
  
  <!-- End Footer inject -->
</footer>

  

  <!-- Begin Body End inject -->
  
  <!-- End Body End inject -->
</body>

</html>
